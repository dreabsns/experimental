<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Neon Hyper Jump</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      overflow: hidden;
      font-family: sans-serif;
      user-select: none;
    }
    canvas { 
      display: block; 
      background: linear-gradient(135deg, #111, #222);
    }
    #scoreBoard {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      font-size: 24px;
      padding: 5px 10px;
      background: rgba(0,0,0,0.5);
      border-radius: 4px;
    }
    #overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      text-align: center;
      padding: 20px;
      background: rgba(0,0,0,0.8);
      border: 2px solid #444;
      border-radius: 8px;
      display: none;
    }
    #overlay button {
      margin-top: 15px;
      padding: 10px 20px;
      font-size: 18px;
      border: none;
      border-radius: 4px;
      background: #28a745;
      color: #fff;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="scoreBoard">Score: 0</div>
  <div id="overlay">
    <div id="gameOverText" style="font-size:32px; margin-bottom:10px;">Game Over!</div>
    <div id="finalScore" style="font-size:24px;"></div>
    <button id="restartButton">Restart</button>
  </div>

  <script>
    /*************************************************************
     * Neon Hyper Jump
     *
     * Controls:
     *   ← / → : Move left/right.
     *   Space : Flip your ball’s color.
     *
     * Bounce on neon platforms! Only land safely if your ball’s
     * color matches the platform. Climb higher, rack up score,
     * and watch the neon world accelerate!
     *************************************************************/

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreBoard = document.getElementById('scoreBoard');
    const overlay = document.getElementById('overlay');
    const finalScoreText = document.getElementById('finalScore');
    const restartButton = document.getElementById('restartButton');

    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    // Colors used in the game (neon blue and neon magenta)
    const COLORS = ['#0ff', '#ff0ff0'];
    
    // Player settings
    const player = {
      x: width / 2,
      y: height - 100,
      radius: 15,
      color: COLORS[0],
      velocityY: 0,
      velocityX: 0,
      speed: 5,
      jumpStrength: -15,
      gravity: 0.6
    };

    // Platform settings and list
    const platforms = [];
    const platformWidth = 120;
    const platformHeight = 15;
    const platformGap = 100; // vertical distance between platforms
    const numPlatforms = Math.ceil(height / platformGap) + 2;

    // Create initial platforms
    function initPlatforms() {
      platforms.length = 0;
      for (let i = 0; i < numPlatforms; i++) {
        let plat = {
          x: Math.random() * (width - platformWidth - 20) + 10,
          y: height - i * platformGap,
          width: platformWidth,
          height: platformHeight,
          color: COLORS[Math.floor(Math.random() * COLORS.length)]
        };
        platforms.push(plat);
      }
    }

    // Input management
    const keys = {};
    window.addEventListener('keydown', e => {
      keys[e.key] = true;
      // Prevent default for arrow keys and space
      if (['ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
    });
    window.addEventListener('keyup', e => {
      keys[e.key] = false;
    });

    // Resize canvas on window resize
    window.addEventListener('resize', () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      // Reinitialize platforms to fill the new screen
      initPlatforms();
    });

    // Game variables
    let score = 0;
    let highestY = player.y; // track highest point reached
    let gameOver = false;

    // Reset game function
    function resetGame() {
      player.x = width / 2;
      player.y = height - 100;
      player.velocityY = 0;
      player.velocityX = 0;
      player.color = COLORS[0];
      score = 0;
      highestY = player.y;
      gameOver = false;
      initPlatforms();
      overlay.style.display = 'none';
      lastTime = performance.now();
      requestAnimationFrame(gameLoop);
    }

    // Event listener for color flip (space bar)
    window.addEventListener('keydown', e => {
      if (e.key === ' ') {
        // Flip color instantly
        player.color = (player.color === COLORS[0]) ? COLORS[1] : COLORS[0];
      }
    });

    // Restart button event
    restartButton.addEventListener('click', resetGame);

    // Main game loop variables
    let lastTime = performance.now();
    function gameLoop(time) {
      if (gameOver) return;
      const deltaTime = time - lastTime;
      lastTime = time;
      update(deltaTime);
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Update game state
    function update(deltaTime) {
      // Horizontal movement
      if (keys['ArrowLeft']) {
        player.velocityX = -player.speed;
      } else if (keys['ArrowRight']) {
        player.velocityX = player.speed;
      } else {
        player.velocityX = 0;
      }
      player.x += player.velocityX;
      // Boundaries
      if (player.x - player.radius < 0) player.x = player.radius;
      if (player.x + player.radius > width) player.x = width - player.radius;
      
      // Apply gravity
      player.velocityY += player.gravity;
      player.y += player.velocityY;
      
      // Check collision with platforms
      platforms.forEach(plat => {
        // Only check if player is falling
        if (player.velocityY > 0) {
          // Simple AABB collision (circle vs. rect approximation)
          if (player.x + player.radius > plat.x &&
              player.x - player.radius < plat.x + plat.width &&
              player.y + player.radius > plat.y &&
              player.y + player.radius < plat.y + plat.height + 10) {
            // Only bounce if colors match
            if (player.color === plat.color) {
              player.velocityY = player.jumpStrength;
            } else {
              // Mismatched color = game over!
              gameOver = true;
            }
          }
        }
      });

      // Update highestY (remember: y decreases as you go up)
      if (player.y < highestY) {
        highestY = player.y;
        score = Math.floor((height - highestY) / 10);
      }

      // If player falls below the bottom, game over
      if (player.y - player.radius > height) {
        gameOver = true;
      }

      // Scroll platforms downward when player goes above a threshold
      const scrollThreshold = height * 0.4;
      if (player.y < scrollThreshold) {
        let scrollAmount = scrollThreshold - player.y;
        player.y = scrollThreshold;
        platforms.forEach(plat => {
          plat.y += scrollAmount;
        });
      }

      // Recycle platforms: if a platform goes off the bottom, move it to the top
      platforms.forEach(plat => {
        if (plat.y - plat.height > height) {
          plat.y = plat.y - height - platformGap;
          plat.x = Math.random() * (width - platformWidth - 20) + 10;
          // Randomize platform color anew
          plat.color = COLORS[Math.floor(Math.random() * COLORS.length)];
        }
      });

      // Update score board
      scoreBoard.textContent = 'Score: ' + score;
      
      // End game overlay
      if (gameOver) {
        finalScoreText.textContent = 'Final Score: ' + score;
        overlay.style.display = 'block';
      }
    }

    // Draw everything
    function draw() {
      // Clear canvas
      ctx.clearRect(0, 0, width, height);

      // Draw platforms
      platforms.forEach(plat => {
        ctx.fillStyle = plat.color;
        // Add a neon glow effect
        ctx.shadowColor = plat.color;
        ctx.shadowBlur = 20;
        ctx.fillRect(plat.x, plat.y, plat.width, plat.height);
      });
      ctx.shadowBlur = 0;

      // Draw player (neon ball)
      ctx.fillStyle = player.color;
      ctx.shadowColor = player.color;
      ctx.shadowBlur = 30;
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    // Start the game
    initPlatforms();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
