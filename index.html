<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Quantum Flux</title>
  <style>
    /* Reset and base styling */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #111;
      overflow: hidden;
      font-family: sans-serif;
      user-select: none;
    }
    canvas {
      display: block;
      background: radial-gradient(ellipse at center, #222, #111);
    }
    #scoreBoard {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 8px 12px;
      font-size: 20px;
      color: #fff;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 4px;
    }
    #overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.85);
      padding: 20px 30px;
      border: 2px solid #444;
      border-radius: 8px;
      color: #fff;
      text-align: center;
      display: none;
    }
    #overlay button {
      margin-top: 15px;
      padding: 10px 20px;
      font-size: 18px;
      border: none;
      border-radius: 4px;
      background: #28a745;
      color: #fff;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="scoreBoard">Score: 0</div>
  <div id="overlay">
    <div style="font-size:32px; margin-bottom:10px;">Game Over!</div>
    <div id="finalScore" style="font-size:24px;"></div>
    <button id="restartButton">Restart</button>
  </div>

  <script>
    /*************************************************************
     * Quantum Flux
     *
     * Concept:
     *   - You control a quantum particle drifting through a neon world.
     *   - Use ↑/↓ arrow keys to move vertically.
     *   - Press Space to flip your phase (blue ↔ red).
     *   - Incoming obstacles and coins have a phase too.
     *       • If phases match, you safely pass (or collect coins).
     *       • If not, collision means game over.
     *   - Enjoy smooth particle effects, glowing animations, and an ever‐increasing challenge!
     *************************************************************/

    // Canvas setup
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreBoard = document.getElementById('scoreBoard');
    const overlay = document.getElementById('overlay');
    const finalScoreText = document.getElementById('finalScore');
    const restartButton = document.getElementById('restartButton');

    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    // Game constants and variables
    const PHASE_COLORS = ["#00aaff", "#ff3366"];  // Phase 0: blue, Phase 1: red
    let gameSpeed = 3;         // Base speed for obstacles and coins
    let obstacleInterval = 1500; // ms between spawns
    let coinInterval = 2500;     // ms between coin spawns
    let lastObstacleTime = 0;
    let lastCoinTime = 0;
    let score = 0;
    let gameOver = false;
    
    // Player object (quantum particle)
    const player = {
      x: width * 0.15,
      y: height / 2,
      radius: 15,
      phase: 0,  // 0 or 1
      color() { return PHASE_COLORS[this.phase]; },
      velocityY: 0,
      speed: 5
    };

    // Arrays for obstacles, coins, and particles (for phase-switch effect)
    const obstacles = []; // Each: { x, y, width, height, phase }
    const coins = [];     // Each: { x, y, radius, phase }
    const particles = []; // Each: { x, y, vx, vy, alpha, color }

    // Input management
    const keys = {};
    window.addEventListener('keydown', e => {
      keys[e.key] = true;
      // Prevent default for arrow keys and space
      if (["ArrowUp", "ArrowDown", " "].includes(e.key)) e.preventDefault();
      // Space toggles phase and spawns particles
      if (e.key === " ") {
        player.phase = player.phase === 0 ? 1 : 0;
        spawnParticles(player.x, player.y, player.color());
      }
    });
    window.addEventListener('keyup', e => { keys[e.key] = false; });

    // Resize canvas on window resize
    window.addEventListener('resize', () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    });

    // Particle effect for phase switching
    function spawnParticles(x, y, color) {
      for (let i = 0; i < 20; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 3 + 1;
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          alpha: 1,
          color
        });
      }
    }

    // Update particles
    function updateParticles(delta) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.alpha -= 0.02 * delta/16;
        if (p.alpha <= 0) particles.splice(i, 1);
      }
    }

    // Spawn an obstacle with random vertical position and phase
    function spawnObstacle() {
      const heightObstacle = 40;
      obstacles.push({
        x: width,
        y: Math.random() * (height - heightObstacle - 20) + 10,
        width: 40,
        height: heightObstacle,
        phase: Math.floor(Math.random() * 2)
      });
    }

    // Spawn a coin with random vertical position and phase
    function spawnCoin() {
      coins.push({
        x: width,
        y: Math.random() * (height - 20) + 10,
        radius: 10,
        phase: Math.floor(Math.random() * 2)
      });
    }

    // Collision detection: circle vs. rectangle for obstacles
    function rectCircleCollide(cx, cy, cr, rx, ry, rw, rh) {
      // Find the closest point on the rectangle
      const closestX = Math.max(rx, Math.min(cx, rx + rw));
      const closestY = Math.max(ry, Math.min(cy, ry + rh));
      const dx = cx - closestX;
      const dy = cy - closestY;
      return (dx * dx + dy * dy) < (cr * cr);
    }

    // Collision detection: circle vs. circle for coins
    function circleCollide(x1, y1, r1, x2, y2, r2) {
      const dx = x1 - x2, dy = y1 - y2;
      return (dx * dx + dy * dy) < ((r1 + r2) * (r1 + r2));
    }

    // Game loop management
    let lastTime = performance.now();
    function gameLoop(now) {
      if (gameOver) return;
      const delta = now - lastTime;
      lastTime = now;
      update(delta);
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Update game objects
    function update(delta) {
      // Player vertical movement using arrow keys
      if (keys["ArrowUp"]) {
        player.y -= player.speed;
      }
      if (keys["ArrowDown"]) {
        player.y += player.speed;
      }
      // Clamp player within canvas
      player.y = Math.max(player.radius, Math.min(height - player.radius, player.y));

      // Increase difficulty over time
      gameSpeed += 0.0005 * delta;

      // Spawn obstacles
      if (performance.now() - lastObstacleTime > obstacleInterval) {
        spawnObstacle();
        lastObstacleTime = performance.now();
      }
      // Spawn coins
      if (performance.now() - lastCoinTime > coinInterval) {
        spawnCoin();
        lastCoinTime = performance.now();
      }

      // Update obstacles (move leftward)
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const obs = obstacles[i];
        obs.x -= gameSpeed * delta/16;
        // Check collision: only dangerous if phases do not match
        if (rectCircleCollide(player.x, player.y, player.radius, obs.x, obs.y, obs.width, obs.height)) {
          if (player.phase !== obs.phase) {
            gameOver = true;
          }
        }
        // Remove off-screen obstacles
        if (obs.x + obs.width < 0) obstacles.splice(i, 1);
      }

      // Update coins (move leftward)
      for (let i = coins.length - 1; i >= 0; i--) {
        const coin = coins[i];
        coin.x -= gameSpeed * delta/16;
        // Check collection: only if phases match
        if (circleCollide(player.x, player.y, player.radius, coin.x, coin.y, coin.radius)) {
          if (player.phase === coin.phase) {
            score += 20;
            coins.splice(i, 1);
            continue;
          }
        }
        // Remove off-screen coins
        if (coin.x + coin.radius < 0) coins.splice(i, 1);
      }

      // Update particles for phase switch effect
      updateParticles(delta);

      // Increment score over time
      score += 0.05 * delta;
      scoreBoard.textContent = "Score: " + Math.floor(score);

      // End game if player collides with obstacle (already set gameOver)
      if (gameOver) {
        finalScoreText.textContent = "Final Score: " + Math.floor(score);
        overlay.style.display = "block";
      }
    }

    // Draw everything
    function draw() {
      // Clear canvas
      ctx.clearRect(0, 0, width, height);

      // Draw background grid effect for added depth
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.05)";
      for (let i = 0; i < width; i += 40) {
        ctx.beginPath();
        ctx.moveTo(i, 0);
        ctx.lineTo(i, height);
        ctx.stroke();
      }
      for (let j = 0; j < height; j += 40) {
        ctx.beginPath();
        ctx.moveTo(0, j);
        ctx.lineTo(width, j);
        ctx.stroke();
      }
      ctx.restore();

      // Draw obstacles with a subtle pulsing glow
      obstacles.forEach(obs => {
        ctx.save();
        ctx.fillStyle = PHASE_COLORS[obs.phase];
        ctx.shadowColor = PHASE_COLORS[obs.phase];
        ctx.shadowBlur = 20 + 5 * Math.sin(performance.now()/200);
        ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
        ctx.restore();
      });

      // Draw coins with a shimmer
      coins.forEach(coin => {
        ctx.save();
        ctx.fillStyle = PHASE_COLORS[coin.phase];
        ctx.shadowColor = PHASE_COLORS[coin.phase];
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(coin.x, coin.y, coin.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });

      // Draw particles for phase-switch effect
      particles.forEach(p => {
        ctx.save();
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });

      // Draw player (quantum particle) with a glowing effect
      ctx.save();
      ctx.fillStyle = player.color();
      ctx.shadowColor = player.color();
      ctx.shadowBlur = 30;
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    // Restart the game on button click
    restartButton.addEventListener('click', () => {
      resetGame();
    });

    // Reset game to initial state
    function resetGame() {
      player.x = width * 0.15;
      player.y = height / 2;
      player.velocityY = 0;
      player.phase = 0;
      obstacles.length = 0;
      coins.length = 0;
      particles.length = 0;
      score = 0;
      gameSpeed = 3;
      gameOver = false;
      overlay.style.display = "none";
      lastObstacleTime = performance.now();
      lastCoinTime = performance.now();
      lastTime = performance.now();
      requestAnimationFrame(gameLoop);
    }

    // Start the game loop
    resetGame();
  </script>
</body>
</html>
